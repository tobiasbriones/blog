<!-- Copyright (c) 2022 Tobias Briones. All rights reserved. -->
<!-- SPDX-License-Identifier: CC-BY-4.0 -->
<!-- This file is part of https://github.com/tobiasbriones/blog -->

# This Article Represents a Milestone for Me (2022/12/18)

I have to say that
[this article](how-i-standardized-hypen-and-pipe-symbols-on-file-names) [I
published 3 days ago](https://github.com/tobiasbriones/blog/pull/20)
represents a milestone for MathSwe content as I've started to work with the
concepts of:

- Composable content.
- Cohesive content.
- Smooth homogeneous content that moves on the system tree.
- Got a new open graph cover.

## Composable Content

This powerful concept will allow readers to move over the system tree
smoothly and enable me to create unlimited scalable articles by writing
focused high-quality content that is decoupled from other topics so that
readers can use composition to deep more withing other details if needed or
just read straight ahead if not needed.

A great representation of the correctness and beauty of functional programming
and composition lies when **you take what you need and don't take what you
don't need** which is something impossible to actually do with other paradigms
(OOP, procedural, imperative, mixed, etc.).

The idea is that the system tree is informed, so we can either read just
about the underlying topic of the article or **expand within other related
content as much as needed** within an **uncoupled** (or composable) ***sum* of
highly-cohesive content that builds a greater whole**.

## Cohesive Content

As an intellectual I always want to write about many contents I have in mind,
but for any article, I've eventually resolved to write or talk about one topic
and leave details or derivative topics that should/must be stated as a draft 
and then build other articles that will be probably related to each other 
but still being highly cohesive.

Now I'm pretty careful about off-topic that must go somewhere else.

Articles must be united wholes that are about the **same** content, so we can
*sum* (scale) them up to build a greater system tree of high-quality content.

## Homogeneous Content

Homogeneous content allows me to achieve simplicity, so I don't need to employ
bureaucratic/academic stereotypes like *heterogeneous sections* that are 
literally called "Introduction", "Body", or "Conclusion" since I'm writing
content as it was source code, and I leverage functional programming for making
informed decisions every day.

All those boilerplate-based and off-topic sections are used to hold 
academic monoliths[^1] and if you're clever enough, you must come out with your 
DSLs because you're a domain expert completely able provide actual value 
instead of off-topic academic and corporate marketing. 

[^1]: Think why Java used to be overly verbose since 90's and 00's software
    (and hardware) were monstrous monoliths and Java was the excellent 
    language for that era

Such sections (for example) are clearly noticed as off-topic since your 
article has a central topic `X` and you're not talking about "Introduction", or 
"Body" but `X`. Those generic boilerplate-driven titles recalls us cheap 
poorly-defined software.

It's like: your app is about `Song-to-Text Recognition` not about stupid 
`Controllers` or `Services` (yes, cheap software built with OOP), those 
generic buzzwords are stereotypes that bypass what an actual engineer would 
do as a domain expert, so I expect modules called like say `["song", "text", 
"transform", "play", "bass", "pitch", "amplitude", "some-ml-model"]` 
instead.

Articles are about the same idea, sometimes we need to think a bit more to 
write what has to be written and that leaves cheap articles behind and 
creates high-quality content.

### How I Homogenized My Previous Article

I'm writing this article as a milestone for paradigm shift and the updates about
content structure is pretty interesting.

I've always put the abstract in the beginning of my writings and make them
as short as possible to resume the whole article.

Now notice how we normally would put sections for "Introduction", 
"Conclusion", etc., when writing formal or semiformal content. As said above,
I don't write about "Introduction" or "Body", I'm not a "Introduction 
Engineer", that is, those are stereotypes for generic/bureaucratic artifacts.

And bureaucrats enforce that kind of repetitive structure to be "correct" 
when in fact they don't have idea of what they're talking about.

Content **must be homogeneous** to give all benefits of its value, 
**homogeneity is key for pureness**.

What I do is **applying informed designs** to systems, so I remove 
boilerplate[^2] and make them ðŸ’¯ original, as if was a huge universe set where
every point is unique[^3], and we *sum* them up as a partition that induces the 
equivalence classes[^4] with the *exact* properties we need which leads to
mathematical elegance and correctness as well as infinitely scalability.

[^2]: Boilerplate is proper of poorly-defined generic software like OO programs
    or also procedural Go programs

[^3]: All elements within a set are unique as the relation that defines 
    whether an element $$x \in X$$ is binary so $$x$$ belongs or not to $$X$$
    and although $$x$$ can be listed many times it is the same element

[^4]: Math or FP classes are not the same as OOP classes at all

I have to say I got quite excited with the previous paragraph ðŸ¤— and it shows
one more time how I'm fully capable of leading the mathematical software 
industry.

Now, notice how I got rid of the "Introduction" stereotype by moving smoothly 
over the sections as if they were **functions** with input and output that can 
obviously be composed, so I created a **particular** section that plays the 
traditional "Introduction" section but being domain-specific or well-informed
instead of being generic:
[Hyphen and Pipe Symbols Semantics in File Names](how-i-standardized-hypen-and-pipe-symbols-on-file-names#hyphen-and-pipe-symbols-semantics-in-file-names).

That section **smoothly** introduces the reader without **imperatively** 
saying it is an "Introduction" (can you see the beauty of FP and DSLs?).

Therefore, all sections can be composed together, and the reader only has to 
read what it's needed and content can be optimally displayed.

Also notice how all everything is homogeneous of course, so a section is the 
same as a whole article or the whole 
[mathsoftware.engineer](https://mathsoftware.engineer) for me so that we can
leverage this pureness to get the most out of the content. That also means 
that every section must have a micro abstract and conclusion to be smooth 
and move from one section to another or skip them.

Then, the "Conclusion" came, so I took **all the inner sections** (without 
abstract, title, and conclusion itself) and **resumed what a reader who 
*already read* the article has achieved** (a.k.a. conclusion) and make it 
original: 
[Standardize Hyphens and Pipes on File Names](how-i-standardized-hypen-and-pipe-symbols-on-file-names#standardize-hyphens-and-pipes-on-file-names),
noticing how I also **micro resumed the section title itself** to eradicate 
the "Conclusion" boilerplate.

Then, that is the output of the article that you can "plug" to a next article to 
get greater value and tha also builds a rich well-informed system.
